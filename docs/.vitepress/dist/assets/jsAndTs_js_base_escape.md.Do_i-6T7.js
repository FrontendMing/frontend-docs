import{_ as s,c as o,o as a,ae as d}from"./chunks/framework.Cd-3tpCq.js";const k=JSON.parse('{"title":"编码","description":"","frontmatter":{},"headers":[],"relativePath":"jsAndTs/js/base/escape.md","filePath":"jsAndTs/js/base/escape.md"}'),i={name:"jsAndTs/js/base/escape.md"};function c(n,e,p,t,l,h){return a(),o("div",null,e[0]||(e[0]=[d('<h1 id="编码" tabindex="-1">编码 <a class="header-anchor" href="#编码" aria-label="Permalink to &quot;编码&quot;">​</a></h1><p>在编写JavaScript代码时，我们常常需要处理URLs，这时候理解JavaScript中的<code>escape</code>，<code>encodeURI</code>和<code>encodeURIComponent</code>函数就显得尤为重要。这些函数用于将特殊字符转化为能在URL中安全传输的形式。本文将详细介绍这三个函数的用法和区别，以帮助你更准确的处理URL编码问题。</p><h2 id="_1-escape函数" tabindex="-1">1. <del>escape</del>函数 <a class="header-anchor" href="#_1-escape函数" aria-label="Permalink to &quot;1. &lt;del&gt;escape&lt;/del&gt;函数&quot;">​</a></h2><blockquote><p>应该弃用</p></blockquote><p>首先，我们来了解一下<code>escape</code>函数。这是一个老旧的函数，现在已经不再推荐使用，因为它不能处理所有的Unicode字符。<code>escape</code>函数会将传入的字符串转化为十六进制的escape序列，这样的序列以<code>%</code>开头。</p><p>然而，这个函数只能正确处理ASCII字符（字符代码小于等于255的字符）。对于ASCII字符代码大于255的字符，<code>escape</code>函数会先将其转化为Unicode转义序列（例如，<code>\\u20AC</code>），然后再对这个转义序列进行编码。这种处理方式会导致一些问题。比如，对于欧元符号（<code>€</code>），它的Unicode代码是<code>20AC</code>，<code>escape</code>函数会将其转化为<code>%u20AC</code>，而不是正确的<code>%E2%82%AC</code>。</p><p>因此，我们不应该再使用<code>escape</code>函数来处理URL编码。</p><h2 id="_2-encodeuri函数" tabindex="-1">2. encodeURI函数 <a class="header-anchor" href="#_2-encodeuri函数" aria-label="Permalink to &quot;2. encodeURI函数&quot;">​</a></h2><p>接下来，我们来看看<code>encodeURI</code>函数。这个函数用于编码完整的URL。它会将非法的URL字符转化为各自的十六进制表示，以<code>%</code>开头。</p><p>然而，<code>encodeURI</code>函数并不会对所有的字符进行编码。一些在URL中有特殊含义的字符，例如<code>/</code>，<code>:</code>，<code>#</code>等，以及ASCII字母，数字和一些符号（<code>- _ . ! ~ * &#39; ( )</code>），不会被<code>encodeURI</code>函数编码。这是因为这些字符在URL中是合法的，可以直接使用。</p><p>下面是一个<code>encodeURI</code>函数的例子：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> url</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;https://example.com/Hello World!&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">encodeURI</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(url)); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// https://example.com/Hello%20World!</span></span></code></pre></div><p>在这个例子中，<code>encodeURI</code>函数将空格字符编码为<code>%20</code>，因为空格在URL中是不合法的。而其他的字符，如<code>/</code>和<code>:</code>等，都没有被编码。</p><h2 id="_3-encodeuricomponent函数" tabindex="-1">3. encodeURIComponent函数 <a class="header-anchor" href="#_3-encodeuricomponent函数" aria-label="Permalink to &quot;3. encodeURIComponent函数&quot;">​</a></h2><p>最后，我们来看看<code>encodeURIComponent</code>函数。这个函数用于编码URL的组成部分，比如查询参数。它会将所有非法的URL字符以及一些有特殊含义的字符（如<code>/</code>，<code>:</code>，<code>#</code>等）转化为各自的十六进制表示。</p><p>这意味着<code>encodeURIComponent</code>函数会对更多的字符进行编码。在大多数情况下，我们都应该使用`encodeURIComponent</p><p>`函数来编码URL的组成部分。</p><p>下面是一个<code>encodeURIComponent</code>函数的例子：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> query</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;/Hello World!&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">encodeURIComponent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(query)); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// %2FHello%20World%21</span></span></code></pre></div><p>在这个例子中，<code>encodeURIComponent</code>函数将<code>/</code>和空格字符都编码了，因为这些字符在URL的查询参数中都是不合法的。</p><h2 id="_4-总结" tabindex="-1">4. 总结 <a class="header-anchor" href="#_4-总结" aria-label="Permalink to &quot;4. 总结&quot;">​</a></h2><p>总的来说，当我们需要编码完整的URL时，应该使用<code>encodeURI</code>函数；而当我们需要编码URL的组成部分，比如查询参数，应该使用<code>encodeURIComponent</code>函数。不再推荐使用<code>escape</code>函数，因为它不能正确处理所有的字符。</p><p>理解和掌握这些函数的用法和区别对于正确处理URL编码问题来说是非常重要的。</p>',23)]))}const g=s(i,[["render",c]]);export{k as __pageData,g as default};
