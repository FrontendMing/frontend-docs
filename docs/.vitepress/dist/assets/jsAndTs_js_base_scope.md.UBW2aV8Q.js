import{_ as a,c as i,o as n,ae as l}from"./chunks/framework.Cd-3tpCq.js";const c=JSON.parse('{"title":"作用域和作用域链","description":"","frontmatter":{},"headers":[],"relativePath":"jsAndTs/js/base/scope.md","filePath":"jsAndTs/js/base/scope.md"}'),t={name:"jsAndTs/js/base/scope.md"};function e(p,s,h,k,r,o){return n(),i("div",null,s[0]||(s[0]=[l(`<h1 id="作用域和作用域链" tabindex="-1">作用域和作用域链 <a class="header-anchor" href="#作用域和作用域链" aria-label="Permalink to &quot;作用域和作用域链&quot;">​</a></h1><h2 id="引言" tabindex="-1">引言 <a class="header-anchor" href="#引言" aria-label="Permalink to &quot;引言&quot;">​</a></h2><p>在 JavaScript 中，作用域是指变量在代码中可访问的范围。理解 JavaScript 的作用域和作用域链对于编写高质量的代码至关重要。本文将详细介绍 JavaScript 中的词法作用域、作用域链和闭包的概念，并探讨它们在实际开发中的应用场景。</p><h2 id="_1-词法作用域" tabindex="-1">1. 词法作用域 <a class="header-anchor" href="#_1-词法作用域" aria-label="Permalink to &quot;1. 词法作用域&quot;">​</a></h2><h3 id="_1-1-概念" tabindex="-1">1.1 概念 <a class="header-anchor" href="#_1-1-概念" aria-label="Permalink to &quot;1.1 概念&quot;">​</a></h3><p>词法作用域是 JavaScript 中最常见的作用域类型。它是在代码编写阶段确定的，而不是在代码执行阶段确定的。在词法作用域中，变量的访问权限是由它们在代码中的位置决定的。</p><h3 id="_1-2-示例" tabindex="-1">1.2 示例 <a class="header-anchor" href="#_1-2-示例" aria-label="Permalink to &quot;1.2 示例&quot;">​</a></h3><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> outer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> outerVariable </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Hello&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> inner</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> innerVariable </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;World&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(outerVariable </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot; &quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> innerVariable);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  inner</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">outer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出: Hello World</span></span></code></pre></div><p>在上面的示例中，函数 <code>inner</code> 内部可以访问外部函数 <code>outer</code> 中定义的变量 <code>outerVariable</code>，这是因为它们处于词法作用域中。词法作用域确保了变量在代码编写阶段就能够正确地被访问。</p><h3 id="_1-3-词法作用域的应用场景" tabindex="-1">1.3 词法作用域的应用场景 <a class="header-anchor" href="#_1-3-词法作用域的应用场景" aria-label="Permalink to &quot;1.3 词法作用域的应用场景&quot;">​</a></h3><p>词法作用域在 JavaScript 中有广泛的应用场景，包括：</p><ul><li><strong>变量访问控制</strong>：词法作用域使得我们可以控制变量的可见性和访问权限，避免命名冲突和变量污染。</li><li><strong>模块化开发</strong>：通过使用函数和闭包，可以实现模块化的代码组织，将变量和函数封装在私有作用域中，提供了良好的封装性和代码组织性。</li><li><strong>函数嵌套</strong>：函数嵌套是 JavaScript 中常见的编程模式，词法作用域确保了内部函数可以访问外部函数的变量，实现了信息的隐藏和封装。</li></ul><h2 id="_2-作用域链" tabindex="-1">2. 作用域链 <a class="header-anchor" href="#_2-作用域链" aria-label="Permalink to &quot;2. 作用域链&quot;">​</a></h2><h3 id="_2-1-概念" tabindex="-1">2.1 概念 <a class="header-anchor" href="#_2-1-概念" aria-label="Permalink to &quot;2.1 概念&quot;">​</a></h3><p>作用域链是 JavaScript 中用于查找变量的一种机制。它由当前作用域和所有父级作用域的变量对象组成。当访问一个变量时，JavaScript 引擎会首先在当前作用域的变量对象中查找，如果找不到，则沿着作用域链向上查找，直到找到变量或者到达全局作用域。</p><div class="language-txt vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">txt</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span></span></span>
<span class="line"><span>Global Execution Context</span></span>
<span class="line"><span>   |</span></span>
<span class="line"><span>   +-- Function Execution Context 1</span></span>
<span class="line"><span>   |      |</span></span>
<span class="line"><span>   |      +-- Function Execution Context 2</span></span>
<span class="line"><span>   |             |</span></span>
<span class="line"><span>   |             +-- Function Execution Context 3</span></span>
<span class="line"><span>   |</span></span>
<span class="line"><span>   +-- Function Execution Context 4</span></span></code></pre></div><h3 id="_2-2-示例" tabindex="-1">2.2 示例 <a class="header-anchor" href="#_2-2-示例" aria-label="Permalink to &quot;2.2 示例&quot;">​</a></h3><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> globalVariable </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Global&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> outer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> outerVariable </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Hello&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> inner</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> innerVariable </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;World&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(globalVariable </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot; &quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> outerVariable </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot; &quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> innerVariable);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  inner</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">outer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出: Global Hello World</span></span></code></pre></div><p>在上面的示例中，函数 <code>inner</code> 内部可以访问全局作用域中定义的变量 <code>globalVariable</code>，以及外部函数 <code>outer</code> 中定义的变量 <code>outerVariable</code>，这是因为 JavaScript 引擎按照作用域链的顺序查找变量。</p><h3 id="_2-3-作用域链的应用场景" tabindex="-1">2.3 作用域链的应用场景 <a class="header-anchor" href="#_2-3-作用域链的应用场景" aria-label="Permalink to &quot;2.3 作用域链的应用场景&quot;">​</a></h3><p>作用域链在 JavaScript 中有多种应用场景，包括：</p><ul><li><strong>变量查找</strong>：作用域链决定了变量的查找顺序，使得 JavaScript 可以正确地找到并访问变量。</li><li><strong>闭包</strong>：通过创建闭包，内部函数可以访问外部函数的变量，实现了信息的保留和共享。</li><li><strong>模块化开发</strong>：作用域链的特性使得我们可以实现模块化的代码组织，将变量和函数封装在私有作用域中，提供了良好的封装性和代码组织性。</li></ul><h2 id="_3-闭包" tabindex="-1">3. 闭包 <a class="header-anchor" href="#_3-闭包" aria-label="Permalink to &quot;3. 闭包&quot;">​</a></h2><h3 id="_3-1-概念" tabindex="-1">3.1 概念 <a class="header-anchor" href="#_3-1-概念" aria-label="Permalink to &quot;3.1 概念&quot;">​</a></h3><p>闭包是指函数和其词法环境的组合。它可以访问其词法作用域中定义的变量，即使在函数外部也可以访问这些变量。闭包在 JavaScript 中常用于创建私有变量和实现模块化开发。</p><h3 id="_3-2-示例" tabindex="-1">3.2 示例 <a class="header-anchor" href="#_3-2-示例" aria-label="Permalink to &quot;3.2 示例&quot;">​</a></h3><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> createCounter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> count </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    count</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(count);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  };</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> counter </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> createCounter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">counter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出: 1</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">counter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出: 2</span></span></code></pre></div><p>在上面的示例中，函数 <code>createCounter</code> 返回一个内部函数，该内部函数引用了外部函数 <code>createCounter</code> 的变量 <code>count</code>。即使在外部函数执行完毕后，内部函数依然可以访问并修改变量 <code>count</code>，这就是闭包的特性。</p><h3 id="_3-3-闭包的应用场景" tabindex="-1">3.3 闭包的应用场景 <a class="header-anchor" href="#_3-3-闭包的应用场景" aria-label="Permalink to &quot;3.3 闭包的应用场景&quot;">​</a></h3><p>闭包在 JavaScript 中有多种应用场景，包括：</p><ul><li><strong>私有变量</strong>：闭包提供了一种实现私有变量的机制，可以隐藏变量并提供访问控制。</li><li><strong>模块化开发</strong>：通过创建闭包，可以实现模块化的代码组织，将变量和函数封装在私有作用域中，提供了良好的封装性和代码组织性。</li><li><strong>延迟执行</strong>：通过使用闭包，可以延迟执行函数，实现异步操作和事件处理。</li></ul><h2 id="_4-总结" tabindex="-1">4. 总结 <a class="header-anchor" href="#_4-总结" aria-label="Permalink to &quot;4. 总结&quot;">​</a></h2><p>作用域、作用域链和闭包是 JavaScript 中重要的概念，它们相互关联，共同构建了 JavaScript 的变量访问和代码组织机制。理解这些概念的原理和应用场景对于编写高质量的 JavaScript 代码至关重要。</p><p>通过词法作用域，我们可以控制变量的可见性和访问权限，实现模块化的代码组织，避免命名冲突和变量污染。</p><p>作用域链决定了变量的查找顺序，使得 JavaScript 可以正确地找到并访问变量。同时，作用域链的特性也为闭包的创建提供了基础，通过闭包，我们可以创建私有变量，实现模块化的代码组织以及延迟执行函数等。</p><p>深入理解作用域、作用域链和闭包，能够帮助我们更好地编写可维护、高效的 JavaScript 代码。</p>`,36)]))}const E=a(t,[["render",e]]);export{c as __pageData,E as default};
