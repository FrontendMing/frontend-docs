import{_ as a,c as i,o as s,ae as e}from"./chunks/framework.Cd-3tpCq.js";const h=JSON.parse('{"title":"响应式方案 - 原子化引擎","description":"","frontmatter":{},"headers":[],"relativePath":"website/responsive.md","filePath":"website/responsive.md"}'),o={name:"website/responsive.md"};function t(n,l,r,S,c,u){return s(),i("div",null,l[0]||(l[0]=[e('<h1 id="响应式方案-原子化引擎" tabindex="-1">响应式方案 - 原子化引擎 <a class="header-anchor" href="#响应式方案-原子化引擎" aria-label="Permalink to &quot;响应式方案 - 原子化引擎&quot;">​</a></h1><h2 id="什么是原子化" tabindex="-1">什么是原子化 <a class="header-anchor" href="#什么是原子化" aria-label="Permalink to &quot;什么是原子化&quot;">​</a></h2><h3 id="原子化的定义" tabindex="-1">原子化的定义 <a class="header-anchor" href="#原子化的定义" aria-label="Permalink to &quot;原子化的定义&quot;">​</a></h3><p>原子化 CSS 是一种 CSS 的架构方式，它倾向于小巧且用途单一的 class，并且会以视觉效果进行命名。</p><p>有些人可能会称其为函数式 CSS，或者 CSS 实用工具。 市面上有不少实用至上的 CSS 框架，如 Tailwind CSS，Windi CSS 等。同时有些 UI 库也会附带一些 CSS 工具类作为框架的补充，如 Bootstrap。</p><h3 id="为什么要使用原子化-css" tabindex="-1">为什么要使用原子化 CSS <a class="header-anchor" href="#为什么要使用原子化-css" aria-label="Permalink to &quot;为什么要使用原子化 CSS&quot;">​</a></h3><ul><li>可以脱离 css 文件，在html直接通过 class 修改样式</li><li>依赖可重用的类，需要编写的 CSS 代码量较少，减少了文件的大小</li><li>非常适合团队协作，代码更加标准化，更易理解，方便后期维护</li><li>gzip压缩，gzip 的核心 Deflate 使用的是LZ77 算法和 Huffman 编码来压缩文件，重复度越高的文件可压缩的空间就越大</li></ul><h3 id="原子化-css-有哪些好处" tabindex="-1">原子化 CSS 有哪些好处 <a class="header-anchor" href="#原子化-css-有哪些好处" aria-label="Permalink to &quot;原子化 CSS 有哪些好处&quot;">​</a></h3><ul><li>效率：比起传统 css/scss，原子化 CSS 效率显著提高，高复用场景也可以使用组合去自定义类</li><li>性能：原子化 CSS 是按需打包，有效减少了 css 代码冗余</li><li>简单：原子化 CSS 降低了心智负担，使得媒体查询、网格布局，以及常见的动画交互样式编写，变得非常简单</li><li>生态：除了内置的预设，社区还有很多第三方预设，让写原子化 CSS 的体验上升</li></ul><h3 id="原子化-css-的核心概念" tabindex="-1">原子化 CSS 的核心概念 <a class="header-anchor" href="#原子化-css-的核心概念" aria-label="Permalink to &quot;原子化 CSS 的核心概念&quot;">​</a></h3><ul><li>功能类优先 <ul><li>不需要为了类的命名而浪费精力</li><li>CSS 停止增长</li><li>更改会更安全</li></ul></li><li>响应式设计 <ul><li>断点语法(前缀)实现 @media 功能</li><li>移动优先</li><li>全面且灵活 -自定义配置</li><li>内容、主题、插件、预设，规则</li><li>完全自定义</li></ul></li></ul><h2 id="原子化原理及优缺点" tabindex="-1">原子化原理及优缺点 <a class="header-anchor" href="#原子化原理及优缺点" aria-label="Permalink to &quot;原子化原理及优缺点&quot;">​</a></h2><h3 id="tailwindcss-原理" tabindex="-1">Tailwindcss 原理 <a class="header-anchor" href="#tailwindcss-原理" aria-label="Permalink to &quot;Tailwindcss 原理&quot;">​</a></h3><blockquote><p>tailwindcss是目前最流行的 css 框架。它是一种基于类名的 CSS 框架，它的核心原理是提供一组可重用的 CSS 类名，开发者可以通过组合这些类名来定义样式</p></blockquote><ul><li>类名定义：Tailwind CSS 提供了大量的 CSS 类名，每个类名都表示一个具体的样式属性和值，例如 &quot;text-red-500&quot; 表示设置文本颜色为红色，颜色值为 #EF4444。</li><li>类名组合：开发者可以通过组合不同的类名来定义样式，例如 &quot;text-red font-bold&quot; 表示设置文本颜色为红色，字体加粗。无需大量手写 CSS ，提高开发效率。</li><li>配置文件：Tailwind CSS 的样式类名和样式属性都是基于一个配置文件定义的。在配置文件中，可以定义颜色、字体、尺寸等变量，这些变量将用于生成样式类名。</li><li>样式生成：Tailwind CSS 会根据配置文件中的变量和样式类名，自动地生成对应的 CSS 样式表。这个样式表包含了所有可重用的样式类名及其对应的样式属性和值，可以直接在 HTML 中引用</li><li>样式输出：在 HTML 中引用 Tailwind CSS 生成的样式表后，你就可以在 HTML 元素中使用 Tailwind CSS 提供的样式类名，从而应用对应的样式</li></ul><p>总的来说，Tailwind CSS 的原理是提供一组可重用的 CSS 类名，通过组合这些类名来定义样式。它的优势在于提供了丰富的样式类名，可以满足不同的样式需求，并且灵活性高。但它的缺点在于学习成本较高，需要花费一些时间学习其类名和样式组合方式。</p><h3 id="unocss-原理" tabindex="-1">Unocss 原理 <a class="header-anchor" href="#unocss-原理" aria-label="Permalink to &quot;Unocss 原理&quot;">​</a></h3><blockquote><p>UnoCSS 是一种基于文本分析的 CSS 框架，它的核心原理是根据你的 HTML 代码自动分析出需要的样式，并生成对应的 CSS 样式表</p></blockquote><ul><li>文本分析：UnoCSS 使用了文本分析技术，它会分析你的 HTML 代码，并根据 HTML 元素的标签名、class、id 等属性，来判断该元素需要应用什么样式</li><li>预处理：在分析 HTML 代码之前，UnoCSS 会先进行一些预处理操作。例如，它会去除 HTML 中的注释、空格和换行符，以便更容易进行文本分析</li><li>样式生成：在文本分析完成后，UnoCSS 会根据分析结果生成对应的 CSS 样式。它会根据你在配置文件中定义的变量和插件，来生成最终的样式表</li><li>样式输出：UnoCSS 会将生成的样式表输出到一个 CSS 文件中，你可以在 HTML 文件中引入该文件，以应用生成的样式</li></ul><p>总的来说，UnoCSS 的原理是通过文本分析技术，自动分析 HTML 代码，并生成对应的 CSS 样式表。它的优势在于减少手写 CSS 的工作量，同时还可以根据你的配置文件自定义样式，从而提高开发效率</p><h3 id="对比-tailwindcss-与-unocss" tabindex="-1">对比 Tailwindcss 与 Unocss <a class="header-anchor" href="#对比-tailwindcss-与-unocss" aria-label="Permalink to &quot;对比 Tailwindcss 与 Unocss&quot;">​</a></h3><p>相同点：</p><ul><li>都提供了一组可重用的 CSS 类，帮助开发者快速构建用户界面</li><li>都可以减少手写 CSS 的工作量，提高开发效率</li><li>都支持自定义变量和插件，满足不同的样式需求 不同点：</li><li>原理不同。Tailwind CSS 是基于类名的 CSS 框架，而 UnoCSS 是基于文本分析的 CSS 框架</li><li>样式设计不同。Tailwind CSS 提供了更多的样式，包括一些高级的样式，可以满足更多的需求</li><li>可定制性不同。TailwindCSS 的样式类名是固定的，UnoCSS 可以自定义生成的样式</li></ul><p>为了更多的灵活性，减少书写时的心智负担，我们在此采用 Unocss 原子化框架引擎，实现一整套响应式方案</p><h2 id="如何使用-unocss" tabindex="-1">如何使用 Unocss <a class="header-anchor" href="#如何使用-unocss" aria-label="Permalink to &quot;如何使用 Unocss&quot;">​</a></h2><h3 id="在-vite-中使用-unocss" tabindex="-1">在 Vite 中使用 Unocss <a class="header-anchor" href="#在-vite-中使用-unocss" aria-label="Permalink to &quot;在 Vite 中使用 Unocss&quot;">​</a></h3><p>见官方文档地址: <a href="https://unocss.dev/integrations/vite" target="_blank" rel="noreferrer">https://unocss.dev/integrations/vite</a></p><h3 id="查看-unocss-按需生成的样式" tabindex="-1">查看 Unocss 按需生成的样式 <a class="header-anchor" href="#查看-unocss-按需生成的样式" aria-label="Permalink to &quot;查看 Unocss 按需生成的样式&quot;">​</a></h3><p>在项目地址后加 <code>__unocss</code> 即可查看<br> 如：<a href="http://localhost:5173/__unocss" target="_blank" rel="noreferrer">http://localhost:5173/__unocss</a></p><h3 id="注意事项" tabindex="-1">注意事项 <a class="header-anchor" href="#注意事项" aria-label="Permalink to &quot;注意事项&quot;">​</a></h3><ul><li>safelist 配置的 class 会作用到全局，建议在文件内使用 @unocss-include，单独扫描文件内的 class</li><li>使用背景图片，建议先上传文件，在用 bg-[url(线上地址)]，因为 Unocss 是按需打包 class 类，如果用本地图片，打包后再改图片地址，打包后的 css 文件是不包括对应的 class 类，会导致背景图片引入失败</li><li>使用官方提供的 transformerVariantGroup 预设插件，简化书写 <ul><li>在使用 unocss 的项目中，可以在 class 类里这样使用：lg:(absolute top-0 left-0 z-1)</li><li>如果要迁移页面的话，则不适用，建议分开写：lg:absolute lg:top-0 lg:left-0 lg:z-1</li></ul></li></ul>',31)]))}const C=a(o,[["render",t]]);export{h as __pageData,C as default};
